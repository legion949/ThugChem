###
# We gather all the information we need to
# carry out the exercise
# Principal objects
atomic_number1 <- as.numeric(as.character(input_atomic_number1))
valence1 <-  as.numeric(as.character(input_valence1))
internal_language <- as.character(input_internal_language)
# Recruited values
symbol1 <- as.character(input_PeriodicTable[[internal_language]][atomic_number1, 2])
name1  <- as.character(input_PeriodicTable[[internal_language]][atomic_number1, 3])
type1 <- as.character(input_PeriodicTable[[internal_language]][atomic_number1, 7])
state1 <- as.character(input_PeriodicTable[[internal_language]][atomic_number1, 9])
# Internal Control
internal_control <- InternalControl_Hydride(input_atomic_number1 = input_atomic_number1,
input_valence1 = input_valence1,
input_internal_language = input_internal_language,
input_external_language = input_external_language,
input_PeriodicTable = input_PeriodicTable)
input_hydride_latex <- HydrideLaTeX(input_atomic_number1 = input_atomic_number1,
input_valence1 = input_valence1,
input_internal_language = "en",
input_external_language = input_external_language,
input_PeriodicTable = input_PeriodicTable)
input_latex <- input_hydride_latex[[2]]
# My armed step
my_armed_step <- paste0("expression(",as.vector(input_latex[input_step,c(2:ncol(input_latex))]), ")")
###
} # End Part 0: Necessary Participants
####################################################
# Part 1: New objects
{
###
# Romans
romans <- c("I", "II", "III", "IV", "V", "VI", "VII", "VIII", " ")
# Roman Valences
r1 <- romans[as.numeric(as.character(input_valence1))]
###
} # End Part 1
#################################################################
# Part 2: Standard Plot Settings
{
###
# Print background
# par(bg = 'orange')
plot(c(0:30), c(0:30), axes=F, col="orange", xlab=" ", ylab=" ")
rect(par("usr")[1],par("usr")[3],par("usr")[2],par("usr")[4], col = "orange", border = "orange")
###
}
#################################
# Part 3: Normal Case and Oxygen Case
{
###
# Normal Case and Oxygen Case
if (internal_control == 1 | internal_control == 2) {
# Completed Chemical Equation
{
###
# GPS       1    2     3      4       5       6      7        8       9
gps_y <- c( 7,   7,    7,     7,      7,     8.5,   8.5,      7,      7)
gps_x <- c( 0,   3,    8,    10,     13,      17,    20,   20.5,   23.5)
my_cex <- c(15,  7,    7,    15,      7,      15,     7,      7,      7)
# Coef 1
text(gps_x[1], gps_y[1], eval(parse(text = my_armed_step[1])), cex = my_cex[1], pos = 4)
# Metal
text(gps_x[2], gps_y[2], eval(parse(text = my_armed_step[2])), cex = my_cex[2], pos = 4)
# Sign +
text(gps_x[3], gps_y[3], eval(parse(text = my_armed_step[3])), cex = my_cex[3], pos = 4)
# Coef 2
text(gps_x[4], gps_y[4], eval(parse(text = my_armed_step[4])), cex = my_cex[4], pos = 4)
# Oxygen
text(gps_x[5], gps_y[5], eval(parse(text = my_armed_step[5])), cex = my_cex[5], pos = 4)
# Arrow
arrows(gps_x[6], gps_y[6], gps_x[7], gps_y[7], lwd = 9, length = 0.70)
# Coef3
text(gps_x[8], gps_y[8], eval(parse(text = my_armed_step[6])), cex = my_cex[6], pos = 4)
# Oxide
text(gps_x[9], gps_y[9], eval(parse(text = my_armed_step[7])), cex = my_cex[7], pos = 4)
} # End Completed Chemical Equation
#################################################
# Valence in Roman Numbers
if(input_roman) {
###
# GPS       1    2     3      4       5       6      7        8       9
gps_y_valence <- gps_y[2] + 10
gps_x_valence <- gps_x[2] + 0.5
my_cex_valence <- c(3)
# Valence in roman numbers
text(gps_x_valence[1], gps_y_valence[1], r1, cex = my_cex_valence[1], pos = 4)
###
} # End Valence
###################################
}
# Plot of Hydride
HydridePlot <-function(input_atomic_number1 = NULL, input_valence1 = NULL,
input_internal_language = "en", input_external_language = NULL,
input_roman = NULL,
input_PeriodicTable = NULL,
input_step = NULL) {
# Internal Settings
{
###
# Important Detail!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# Internally are using "en" (English) as internal language and options.
# The input_optional_language is for select some correct options form each language
# in the output.
input_internal_language <- "en"
if (is.null(input_external_language)) input_external_language <- "en"
if (is.null(input_step)) input_step <- 1
if (is.null(input_roman)) input_roman <- TRUE
###
} # End Internal Settings
##########################################################################
# Part 0: Necessary Participants
{
###
# We gather all the information we need to
# carry out the exercise
# Principal objects
atomic_number1 <- as.numeric(as.character(input_atomic_number1))
valence1 <-  as.numeric(as.character(input_valence1))
internal_language <- as.character(input_internal_language)
# Recruited values
symbol1 <- as.character(input_PeriodicTable[[internal_language]][atomic_number1, 2])
name1  <- as.character(input_PeriodicTable[[internal_language]][atomic_number1, 3])
type1 <- as.character(input_PeriodicTable[[internal_language]][atomic_number1, 7])
state1 <- as.character(input_PeriodicTable[[internal_language]][atomic_number1, 9])
# Internal Control
internal_control <- InternalControl_Hydride(input_atomic_number1 = input_atomic_number1,
input_valence1 = input_valence1,
input_internal_language = input_internal_language,
input_external_language = input_external_language,
input_PeriodicTable = input_PeriodicTable)
input_hydride_latex <- HydrideLaTeX(input_atomic_number1 = input_atomic_number1,
input_valence1 = input_valence1,
input_internal_language = "en",
input_external_language = input_external_language,
input_PeriodicTable = input_PeriodicTable)
input_latex <- input_hydride_latex[[2]]
# My armed step
my_armed_step <- paste0("expression(",as.vector(input_latex[input_step,c(2:ncol(input_latex))]), ")")
###
} # End Part 0: Necessary Participants
####################################################
# Part 1: New objects
{
###
# Romans
romans <- c("I", "II", "III", "IV", "V", "VI", "VII", "VIII", " ")
# Roman Valences
r1 <- romans[as.numeric(as.character(input_valence1))]
###
} # End Part 1
#################################################################
# Part 2: Standard Plot Settings
{
###
# Print background
# par(bg = 'orange')
plot(c(0:30), c(0:30), axes=F, col="orange", xlab=" ", ylab=" ")
rect(par("usr")[1],par("usr")[3],par("usr")[2],par("usr")[4], col = "orange", border = "orange")
###
}
#################################
# Part 3: Normal Case and Oxygen Case
{
###
# Normal Case and Oxygen Case
if (internal_control == 1 | internal_control == 2) {
# Completed Chemical Equation
{
###
# GPS       1    2     3      4       5       6      7        8       9
gps_y <- c( 7,   7,    7,     7,      7,     8.5,   8.5,      7,      7)
gps_x <- c( 0,   3,    8,    10,     13,      17,    20,   20.5,   23.5)
my_cex <- c(15,  7,    7,    15,      7,      15,     7,      7,      7)
# Coef 1
text(gps_x[1], gps_y[1], eval(parse(text = my_armed_step[1])), cex = my_cex[1], pos = 4)
# Metal
text(gps_x[2], gps_y[2], eval(parse(text = my_armed_step[2])), cex = my_cex[2], pos = 4)
# Sign +
text(gps_x[3], gps_y[3], eval(parse(text = my_armed_step[3])), cex = my_cex[3], pos = 4)
# Coef 2
text(gps_x[4], gps_y[4], eval(parse(text = my_armed_step[4])), cex = my_cex[4], pos = 4)
# Oxygen
text(gps_x[5], gps_y[5], eval(parse(text = my_armed_step[5])), cex = my_cex[5], pos = 4)
# Arrow
arrows(gps_x[6], gps_y[6], gps_x[7], gps_y[7], lwd = 9, length = 0.70)
# Coef3
text(gps_x[8], gps_y[8], eval(parse(text = my_armed_step[6])), cex = my_cex[6], pos = 4)
# Oxide
text(gps_x[9], gps_y[9], eval(parse(text = my_armed_step[7])), cex = my_cex[7], pos = 4)
} # End Completed Chemical Equation
#################################################
# Valence in Roman Numbers
if(input_roman) {
###
# GPS       1    2     3      4       5       6      7        8       9
gps_y_valence <- gps_y[2] + 10
gps_x_valence <- gps_x[2] + 0.5
my_cex_valence <- c(3)
# Valence in roman numbers
text(gps_x_valence[1], gps_y_valence[1], r1, cex = my_cex_valence[1], pos = 4)
###
} # End Valence
###################################
}
# Plot of Hydride
HydridePlot <-function(input_atomic_number1 = NULL,
input_valence1 = NULL,
input_internal_language = "en", input_external_language = NULL,
input_roman = NULL,
input_PeriodicTable = NULL,
input_step = NULL) {
# Internal Settings
{
###
# Important Detail!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# Internally are using "en" (English) as internal language and options.
# The input_optional_language is for select some correct options form each language
# in the output.
input_internal_language <- "en"
if (is.null(input_external_language)) input_external_language <- "en"
if (is.null(input_step)) input_step <- 1
if (is.null(input_roman)) input_roman <- TRUE
###
} # End Internal Settings
##########################################################################
# Part 0: Necessary Participants
{
###
# We gather all the information we need to
# carry out the exercise
# Principal objects
atomic_number1 <- as.numeric(as.character(input_atomic_number1))
valence1 <-  as.numeric(as.character(input_valence1))
internal_language <- as.character(input_internal_language)
# Recruited values
symbol1 <- as.character(input_PeriodicTable[[internal_language]][atomic_number1, 2])
name1  <- as.character(input_PeriodicTable[[internal_language]][atomic_number1, 3])
type1 <- as.character(input_PeriodicTable[[internal_language]][atomic_number1, 7])
state1 <- as.character(input_PeriodicTable[[internal_language]][atomic_number1, 9])
# Internal Control
internal_control <- InternalControl_Hydride(input_atomic_number1 = input_atomic_number1,
input_valence1 = input_valence1,
input_internal_language = input_internal_language,
input_external_language = input_external_language,
input_PeriodicTable = input_PeriodicTable)
input_hydride_latex <- HydrideLaTeX(input_atomic_number1 = input_atomic_number1,
input_valence1 = input_valence1,
input_internal_language = "en",
input_external_language = input_external_language,
input_PeriodicTable = input_PeriodicTable)
input_latex <- input_hydride_latex[[2]]
# My armed step
my_armed_step <- paste0("expression(",as.vector(input_latex[input_step,c(2:ncol(input_latex))]), ")")
###
} # End Part 0: Necessary Participants
####################################################
# Part 1: New objects
{
###
# Romans
romans <- c("I", "II", "III", "IV", "V", "VI", "VII", "VIII", " ")
# Roman Valences
r1 <- romans[as.numeric(as.character(input_valence1))]
###
} # End Part 1
#################################################################
# Part 2: Standard Plot Settings
{
###
# Print background
# par(bg = 'orange')
plot(c(0:30), c(0:30), axes=F, col="orange", xlab=" ", ylab=" ")
rect(par("usr")[1],par("usr")[3],par("usr")[2],par("usr")[4], col = "orange", border = "orange")
###
}
#################################
# Part 3: Normal Case and Oxygen Case
{
###
# Normal Case and Oxygen Case
if (internal_control == 1 | internal_control == 2) {
# Completed Chemical Equation
{
###
# GPS       1    2     3      4       5       6      7        8       9
gps_y <- c( 7,   7,    7,     7,      7,     8.5,   8.5,      7,      7)
gps_x <- c( 0,   3,    8,    10,     13,      17,    20,   20.5,   23.5)
my_cex <- c(15,  7,    7,    15,      7,      15,     7,      7,      7)
# Coef 1
text(gps_x[1], gps_y[1], eval(parse(text = my_armed_step[1])), cex = my_cex[1], pos = 4)
# Metal
text(gps_x[2], gps_y[2], eval(parse(text = my_armed_step[2])), cex = my_cex[2], pos = 4)
# Sign +
text(gps_x[3], gps_y[3], eval(parse(text = my_armed_step[3])), cex = my_cex[3], pos = 4)
# Coef 2
text(gps_x[4], gps_y[4], eval(parse(text = my_armed_step[4])), cex = my_cex[4], pos = 4)
# Oxygen
text(gps_x[5], gps_y[5], eval(parse(text = my_armed_step[5])), cex = my_cex[5], pos = 4)
# Arrow
arrows(gps_x[6], gps_y[6], gps_x[7], gps_y[7], lwd = 9, length = 0.70)
# Coef3
text(gps_x[8], gps_y[8], eval(parse(text = my_armed_step[6])), cex = my_cex[6], pos = 4)
# Oxide
text(gps_x[9], gps_y[9], eval(parse(text = my_armed_step[7])), cex = my_cex[7], pos = 4)
} # End Completed Chemical Equation
#################################################
# Valence in Roman Numbers
if(input_roman) {
###
# GPS       1    2     3      4       5       6      7        8       9
gps_y_valence <- gps_y[2] + 10
gps_x_valence <- gps_x[2] + 0.5
my_cex_valence <- c(3)
# Valence in roman numbers
text(gps_x_valence[1], gps_y_valence[1], r1, cex = my_cex_valence[1], pos = 4)
###
} # End Valence
###################################
}
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
OxacidNomenclature <- function(input_atomic_number1 = NULL,
input_valence1 = NULL,
input_family = "Oxacid",
input_internal_language = "en",
input_external_language = NULL,
input_PeriodicTable = NULL,
input_Nomenclature = NULL) {
# Internal Settings
{
###
# Internal language specifications by default and optional if null
input_internal_language <- "en"
if (is.null(input_external_language)) input_external_language <- input_internal_language
# If is null the input_family
#  if (is.null(input_family)) input_family <- "Oxide"
###
} # End Internal Settings
##########################################################################
# Part 0: Necessary Participants
{
###
# Element Values
element_values1 <- Internal_ElementValues(input_atomic_number1 = input_atomic_number1,
input_valence1 = input_valence1,
input_internal_language = input_internal_language,
input_external_language = input_external_language,
input_PeriodicTable = input_PeriodicTable)
# Internal Control
internal_control <- InternalControl_Oxacid(input_atomic_number1 = input_atomic_number1,
input_valence1 = input_valence1,
input_internal_language = input_internal_language,
input_external_language = input_external_language,
input_PeriodicTable = input_PeriodicTable)
# Oxacid Resolution
input_oxacid_resolution <- OxacidEquation(input_atomic_number1 = input_atomic_number1,
input_valence1 = input_valence1,
input_internal_language = "en",
input_external_language = input_external_language,
input_PeriodicTable = input_PeriodicTable)
# LaTeX resolution
input_oxacid_latex <- OxacidLaTeX(input_atomic_number1 = input_atomic_number1,
input_valence1 = input_valence1,
input_internal_language = "en",
input_external_language = input_external_language,
input_PeriodicTable = input_PeriodicTable)
input_latex <- input_oxacid_latex[[2]]
# Chemestry Formule
chemestry_formule_resolution <- input_oxacid_resolution[ncol(input_latex), c(13:18)]
chemestry_formule_latex <- input_latex[ncol(input_latex), 8]
amount1 <- as.numeric(as.character(chemestry_formule_resolution[1,2]))
amount2 <- as.numeric(as.character(chemestry_formule_resolution[1,4]))
###
} # End Parte 0
##############################################
# Part 1: Other Necessary Items
{
###
# Roman numerals
romans <- c("I", "II", "III", "IV", "V", "VI", "VII", "")
prefixes <- Nomenclature$Prefixes[[input_external_language]]
medium_part_classic <- Nomenclature$General01[[input_external_language]]
# This position is only for Oxacid
my_pos <- 3
###
} # Part 1
############################################
# Part2: General Nomenclature
{
###
# Only nomenclature for Oxacid in the selected language
complete_nomenclature <- Nomenclature[[input_family]][[input_external_language]]
# Some details...
position <- ncol(complete_nomenclature)
stock_nomenclature <- complete_nomenclature[,12]
classic_nomenclature <- complete_nomenclature[,c(7:11)]
iupac_nomenclature <- complete_nomenclature[,13]
detail_nomenclature <- complete_nomenclature[,14]
set_names <- input_Nomenclature$General02[[input_external_language]][,2]
# Special Details
language_pos <-        c(2,  3,  2)
names(language_pos) <- c("en", "es", "fr")
special_detail <- language_pos[names(language_pos) == input_external_language]
###
} # End Part2
#####################################################
# Part3: Isolate Nomenclature
{
###
pre01 <- prefixes[amount1, 2]
pre02 <- prefixes[amount2, 2]
my_name <- element_values1$name
my_roman <- romans[element_values1$selected_valence]
my_family <- medium_part_classic[my_pos, special_detail]
my_iupac_nomenclature <- iupac_nomenclature[input_atomic_number1]
my_stock_nomenclature <- stock_nomenclature[input_atomic_number1]
my_classic_nomenclature <- classic_nomenclature[input_atomic_number1, element_values1$order_selected_valence]
my_detail_nomenclature <- detail_nomenclature[input_atomic_number1]
###
} # End Part3
#########################################
# Part4: Nomenclature System
{
###
# Modifications for Language English
if (input_external_language == "en") {
# IUPAC
iupac <- "Coming Soon!"
# Stock
stock <- "Coming Soon!"
# Classic
classic <- "Coming Soon!"
}
# Modifications for Language Spanish
if (input_external_language == "es") {
# IUPAC
iupac <- paste0(pre01, my_iupac_nomenclature, " ", my_detail_nomenclature)
# Stock
stock <- paste0(my_stock_nomenclature, " ", "(", my_roman, ")", " ", my_detail_nomenclature)
# Classic
classic <- my_classic_nomenclature
# Writing spanish errors
iupac <- gsub("oÓ", "ó", iupac)
iupac <- gsub("aÓ", "ó", iupac)
}
###
} # End Part4
################################################
# Part5: My exit
{
###
# Save all
nomenclature_system01 <- c(iupac, stock, classic, chemestry_formule_latex)
nomenclature_system02 <- paste0(set_names, ": ", nomenclature_system01)
nomenclature_system03 <- set_names
my_exit <- as.data.frame(rbind(nomenclature_system01, nomenclature_system02,
nomenclature_system03))
colnames(my_exit) <- set_names
###
} # End: Part 5
###################################################
# Part6: Return
{
###
return(my_exit)
###
} # End Part6
######################################
} # End Function OxacidNomenclature***
input_atomic_number1 <- 23 #Carbono
input_valence1 <- 2
input_internal_language <- "en"
input_external_language <- "es"
input_family <- "Oxacid"
input_PeriodicTable <- PeriodicTable
input_Nomenclature <- Nomenclature
OxacidNomenclature(input_atomic_number1 = input_atomic_number1,
input_valence1 = input_valence1,
input_family = input_family,
input_internal_language = input_internal_language,
input_external_language = input_external_language,
input_PeriodicTable = input_PeriodicTable,
input_Nomenclature = input_Nomenclature)
input_atomic_number1 <- 23 #Carbono
input_valence1 <- 2
input_internal_language <- "en"
input_external_language <- "es"
input_family <- "Oxacid"
input_PeriodicTable <- PeriodicTable
input_Nomenclature <- Nomenclature
OxacidNomenclature(input_atomic_number1 = input_atomic_number1,
input_valence1 = input_valence1,
input_family = input_family,
input_internal_language = input_internal_language,
input_external_language = input_external_language,
input_PeriodicTable = input_PeriodicTable,
input_Nomenclature = input_Nomenclature)
runApp()
runApp()
